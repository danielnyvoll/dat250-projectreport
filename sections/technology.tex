\section{Software Technology Stack}
\label{sec:technology}

\subsection{React and Tailwind: Frontend Infrastructure}
For our frontend, we chose to use React and Tailwind. As noted by Goadrich and Rogers, ``However, conclusions show that React Native exhibits the best outcomes when taking into consideration the operating systems'' \cite[p.~611]{goadrich2011smart}. It allows us to create large web applications that can change data, without reloading the page.
Tailwind CSS is a utility-first CSS framework that has been gaining popularity for its unique approach to styling web applications. 
Here's a detailed explanation of why React and Tailwind CSS is an excellent choice for the front-end development of our web application:

React's core strength lies in its component-based architecture. This approach enables developers to build encapsulated components that manage their own state, and then compose them to make complex user interfaces. 
By breaking down the UI into individual components, React promotes reusability, which can significantly speed up development time and reduce code redundancy.

Each component has a well-defined lifecycle, and React provides hooks into these lifecycle events. 
For instance, developers can execute code at the moment a component mounts, updates, or unmounts, giving fine-grained control over its behavior.

React is declarative, meaning that developers write code that describes the UI, and React takes care of updating the Document Object Model (DOM) to match that description. 
When the state of a component changes, React updates only the parts of the DOM that have changed. 
This declarative update process simplifies the code and makes it more predictable, which is crucial for the maintainability of large applications.

React has a large and active community, which translates into a wealth of third-party components, libraries, and tools that extend its capabilities. 
The ecosystem around React includes state management libraries like Redux and MobX, routing solutions like React Router, and numerous other utilities that complement React's feature set.

Developer experience is another strong suit for React. It offers a robust set of developer tools, including React Developer Tools, which is a browser extension for debugging component trees. 
It also provides meaningful warnings and error messages that help developers quickly identify and resolve issues.

Tailwind CSS enhances developer experience by allowing them to stay in the HTML for the majority of the styling work, which reduces context switching between HTML and CSS files. 
This can lead to faster development cycles and increased productivity. The utility classes are also self-explanatory, which makes the code easier to read and understand at a glance.

Tailwind CSS employs a utility-first approach to styling, which is a significant shift from traditional CSS frameworks that provide UI kits with predefined component styles. 
Instead of using semantic class names tied to specific components, Tailwind provides low-level utility classes that can be composed to build any design, directly in the markup. This approach makes it incredibly flexible and reduces the need to write custom CSS to an absolute minimum.

Because Tailwind encourages the use of utility classes, the size of CSS files tends to be smaller, which can lead to performance gains. 
When combined with its JIT compiler, Tailwind generates the minimal amount of CSS needed for a project, leading to faster load times and improved overall performance of the web application.

\subsection{Spring Boot: Back-End Infrastructure}
Spring Boot is an extension of the Spring framework that simplifies the initial setup and development of new Spring applications.\cite{springboot2023} 
It favors convention over configuration and is designed to get you up and running as quickly as possible. Here's a detailed explanation of why Spring Boot is an excellent choice for our back-end infrastructure:

Spring Boot simplifies the management of application configurations. 
It eliminates the need for defining boilerplate configuration with its auto-configuration feature.
This feature automatically configures your application based on the libraries present on the classpath. 
This can significantly reduce development time and increase productivity because developers can focus on the unique aspects of their application rather than on infrastructure setup. 

Spring Boot makes it easy to create standalone, production-grade Spring-based applications that can be run directly from the command line without requiring an external web server. 
This is made possible by embedding servers like Tomcat, Jetty, or Undertow directly in the application. 
The ability to run as a standalone app simplifies both the development and the deployment processes.

To streamline the configuration process, Spring Boot provides a set of 'starter' dependencies that bundle the necessary libraries to get a feature working. 
These starters cover many Spring Boot features, such as data access, messaging, and web services. 
Using starters, you can avoid library version conflicts and ensure that you're using a set of dependencies that Spring Boot has tested and approved.

Spring Boot benefits from the strong support of the vibrant and extensive Spring community. 
There are numerous guides, tutorials, and a comprehensive reference documentation available. 
Moreover, the community support forums and Stack Overflow are active and helpful in solving problems.

Spring Boot has excellent integration with Spring Data, which simplifies database access and provides support for various data access technologies, including JPA, JDBC, and NoSQL. 
Spring Boot also works well with Hibernate - one of the most popular ORM tools - making it easier to work with databases using an object-oriented paradigm.

\subsection{RabbitMQ and Dweet.io: Message Systems}

RabbitMQ, an open-source message broker, is chosen for its reliability, scalability, and flexibility in handling application messaging systems.\cite{RabbitamqpSpec} It serves as a platform-neutral intermediary, enabling asynchronous communication between services with support for various messaging protocols, intricate queuing, and multiple exchange types. This ensures flexible routing and enhances system robustness by allowing producers and consumers to scale independently. Additionally, RabbitMQ's features like message durability, persistent queues, and capability to operate in high-load environments with consistent hashing and sharding make it ideal for maintaining application integrity and managing high message volumes.

Complementing RabbitMQ, Dweet.io offers a simplified solution for real-time messaging, especially beneficial for Internet of Things (IoT) applications. It enables devices to "dweet" messages for instant access by subscribed clients, emphasizing timely data delivery with minimal setup requirements. This makes Dweet.io highly accessible for immediate deployment and integration.

Together, RabbitMQ and Dweet.io provide a comprehensive messaging solution. RabbitMQ handles the heavy-duty, reliable queuing and processing of messages, while Dweet.io contributes with its real-time messaging capabilities, ensuring a responsive and interconnected application ecosystem.



\subsection{JPA, Hibernate and H2: Data Management and Storing}

Java Persistence API (JPA) is a Java specification providing an Object-Relational Mapping (ORM) standard. 
This abstraction simplifies the interaction between Java objects and relational databases. 
JPA's primary advantage lies in its database-agnostic nature, offering flexibility in database choice and minimal application code changes when switching databases.

Hibernate, as an implementation of JPA, enhances its capabilities. 
It's renowned for its performance optimization features, such as lazy loading and sophisticated caching mechanisms. 
Hibernate also supports a rich set of querying capabilities through the Hibernate Query Language (HQL) and Criteria API, enabling more complex and efficient data retrieval operations. 
According to a study presented at the 2021 23rd International Conference on Control Systems and Computer Science, "ORM (object/relational mapping) has now widespread. This is mainly due to Hibernate, an open-source ORM, and Spring Data, an umbrella project from the Spring family whose purpose is to unify and facilitate access to different kinds of persistence stores, including relational database systems and NoSQL databases" \cite{orm2021cscs}.
Together, JPA and Hibernate offer:

\begin{itemize}
  \item \textbf{Simplified Database Interactions}: By abstracting complex JDBC operations, they reduce boilerplate code and streamline database interactions.
  \item \textbf{Advanced Query Capabilities}: Enhanced querying and retrieval options facilitate sophisticated data handling.
  \item \textbf{Performance Optimizations}: Features like caching and batching improve application performance and database interaction efficiency.
\end{itemize}

The H2 database is an in-memory, Java-based database known for its speed and simplicity. 
Primarily used in development and testing environments, H2 stands out for its ease of setup and rapid execution. 
It offers a web console for direct database interactions, enhancing its usability during development.




\subsection{Firebase: Authentication (New Technology)}

Firebase Authentication provides a full backend service that can authenticate users through multiple methods, including passwords, phone numbers, popular federated identity providers like Google, Facebook, and Twitter, and more. The decision to use Firebase for authentication in the application is based on its comprehensive suite of features that enhance user security and improve the overall user experience.

Firebase Authentication offers a seamless integration with applications, providing a complete identity solution supporting email/password auth, social media login, and phone authentication. Its SDKs and ready-made UI libraries allow for quick implementation of secure user authentication.

The service not only handles user authentication but also manages user accounts and sessions with ease. It's equipped with features such as email and password reset, account verification, and sign-in link capabilities, which contribute to a robust authentication flow.

According to Pramono and Javista, Firebase Authentication ensures that user credentials are securely managed and stored, preventing users from manipulating data or using the identity of another user due to its security and strict data verification process \cite{pramono2021firebase}. The platform is compliant with identity standards such as OAuth 2.0 and OpenID Connect, so user data is handled in a secure and standardized manner.

Designed to handle large-scale applications, Firebase Authentication can effortlessly scale to accommodate millions of users. The flexibility offered by Firebase allows developers to focus on the user experience while Firebase takes care of the authentication backend.

Firebase Authentication is part of the larger Firebase ecosystem, which means it can be easily integrated with other Firebase services like Firestore, Firebase Realtime Database, and Firebase Cloud Functions. This integration provides a seamless development experience and allows for the creation of sophisticated, authenticated workflows.

By incorporating Firebase Authentication, the application streamlines the user sign-in process and ensures that authentication is handled safely and efficiently, allowing developers to focus on building features that add value to the user experience rather than the intricacies of user security management.
